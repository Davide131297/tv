import { GoogleGenAI } from "@google/genai";

// Rate-Limiting f√ºr AI-Requests
let aiRequestCount = 0;
let lastRequestTime = 0;
const REQUEST_DELAY_MS = 4000;
const MAX_RETRIES = 3;
const ai = new GoogleGenAI({ apiKey: process.env.GOOGLE_GENAI_API_KEY || "" });
const googleModel = process.env.GOOGLE_AI_MODEL || "gemini-2.0-flash";

async function waitForRateLimit(): Promise<void> {
  const now = Date.now();
  const timeSinceLastRequest = now - lastRequestTime;

  if (timeSinceLastRequest < REQUEST_DELAY_MS) {
    const waitTime = REQUEST_DELAY_MS - timeSinceLastRequest;
    console.log(`   ‚è±Ô∏è Warte ${waitTime}ms wegen Rate Limit...`);
    await new Promise((resolve) => setTimeout(resolve, waitTime));
  }

  lastRequestTime = Date.now();
  aiRequestCount++;
}

export async function extractGuestsWithAI(
  description: string,
  retryCount = 0
): Promise<string[]> {
  // Nach 150 Requests direkt zum Fallback wechseln
  if (aiRequestCount >= 150) {
    console.log("‚ö†Ô∏è  AI Rate Limit erreicht");
    return [];
  }

  await waitForRateLimit();

  const prompt = `Text: ${description}
Gib mir die Namen der G√§ste im Text ausschlie√ülich als JSON Array mit Strings zur√ºck. Keine Erkl√§rungen, kein Codeblock, nichts davor oder danach.`;

  try {
    console.log(
      `ü§ñ Extrahiere G√§ste mit AI (Request ${aiRequestCount}/150)...`
    );

    const response = await ai.models.generateContent({
      model: googleModel,
      contents: prompt,
      config: {
        systemInstruction:
          'Du extrahierst ausschlie√ülich Personennamen und antwortest nur mit einem g√ºltigen JSON Array von Strings (z.B. ["Name1","Name2",...]). Keine zus√§tzlichen Zeichen.',
      },
    });

    const content = response.text ?? "";

    const arrayMatch = content.match(/\[[\s\S]*\]/);
    if (arrayMatch) {
      try {
        const parsed = JSON.parse(arrayMatch[0]);
        if (
          Array.isArray(parsed) &&
          parsed.every((x) => typeof x === "string")
        ) {
          console.log(`   ‚úÖ AI extrahierte ${parsed.length} G√§ste:`, parsed);
          return parsed;
        }
      } catch {
        // ignorieren
      }
    }

    console.log("‚ö†Ô∏è  AI-Extraktion unerwartetes Format");
    return [];
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : "Unbekannter Fehler";
    console.error(
      `‚ùå AI-Extraktion fehlgeschlagen (Versuch ${
        retryCount + 1
      }/${MAX_RETRIES}): ${errorMessage}`
    );

    // Retry bei bestimmten Fehlern
    if (
      retryCount < MAX_RETRIES - 1 &&
      (errorMessage.includes("rate") ||
        errorMessage.includes("timeout") ||
        errorMessage.includes("503") ||
        errorMessage.includes("502"))
    ) {
      const backoffDelay = Math.pow(2, retryCount) * 2000;
      console.log(`   üîÑ Retry in ${backoffDelay}ms...`);
      await new Promise((resolve) => setTimeout(resolve, backoffDelay));
      return extractGuestsWithAI(description, retryCount + 1);
    }

    return [];
  }
}

export async function getPoliticalArea(
  description: string
): Promise<number[] | []> {
  // Prompt √§hnlich wie in test-ai-connection.ts
  const prompt = `Text: ${description}
  Gib die Themengebiete wieder die in der Talkshow besprochen wurden. Die Vorhandenen Themenfelder sind vorgegeben. Gib die Antowrt als Array [id] zur√ºck. M√∂gliche Themenfelder: 1. Energie, Klima und Versorgungssicherheit 2. Wirtschaft, Innovation und Wettbewerbsf√§higkeit 3. Sicherheit, Verteidigung und Au√üenpolitik 4. Migration, Integration und gesellschaftlicher Zusammenhalt 5. Haushalt, √∂ffentliche Finanzen und Sozialpolitik 6. Digitalisierung, Medien und Demokratie 7. Kultur, Identit√§t und Erinnerungspolitik`;

  try {
    console.log("ü§ñ Erkenne Themen der Episode");

    const response = await ai.models.generateContent({
      model: googleModel,
      contents: prompt,
      config: {
        systemInstruction:
          "Du antwortest nur mit einem g√ºltigen JSON Array von numbers (z.B. [1,2,...]). Keine zus√§tzlichen Zeichen.",
      },
    });

    const content = response.text?.trim() ?? "";

    try {
      const parsed = JSON.parse(content);
      if (
        Array.isArray(parsed) &&
        parsed.every((item) => typeof item === "number")
      ) {
        return parsed;
      }
    } catch {
      console.error("‚ùå AI-Antwort kein g√ºltiges JSON-Array:", content);
      return [];
    }

    return [];
  } catch {
    console.error("‚ùå AI-Extraktion fehlgeschlagen");
    return [];
  }
}
